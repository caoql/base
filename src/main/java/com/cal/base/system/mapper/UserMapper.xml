<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用，namespace等于mapper接口地址 -->

<!-- 1.${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。 使用${}拼接sql，引起 sql注入 ${value}：接收输入 
	参数的内容，如果传入类型是简单类型，${}中只能使用value 2.#{}:表示一个占位符号 #{id}：其中的id表示接收输入 的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意，可以value或其它名称 -->
<mapper namespace="com.cal.base.system.mapper.UserMapper">
	<!-- 开启本mapper的namespace下的二缓存,UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap）。 
	type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache
	要和ehcache整合，需要配置type为ehcache实现cache接口的类型
	注意：开启二级缓存之后查询的结果映射到的pojo必须实现序列化，因为二级缓存数据存储介质多种多样，不一定在内存。
	 -->
	<!-- <cache type="org.mybatis.caches.ehcache.EhcacheCache"/> -->
	<cache eviction="LRU" type="com.cal.base.common.cache.RedisCache" flushInterval="5"/>
	
	<!-- 定义resultMap 将表的字段和pojo类中的属性作一个映射关系 type：resultMap最终映射的java对象类型,可以使用别名 
		id：对resultMap的唯一标识 -->
	<resultMap id="BaseResultMap" type="User">
		<!-- id表示查询结果集中唯一标识 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 
			（对应关系） -->
		<id column="USER_ID" property="userId" />
		<!-- result：对普通名映射定义 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 
			（对应关系） -->
		<result column="ACCOUNT" property="account" />
		<result column="NAME" property="name" />
		<result column="PASSWORD" property="password" />
		<result column="PHONE" property="phone" />
		<result column="SEX" property="sex" jdbcType="CHAR" />
		<result column="SYSCODE" property="syscode" />
		<result column="ORG_ID" property="orgId" />
		<result column="IS_ENABLED" property="isEnabled" />
		<result column="REMARK" property="remark" />
		<result column="CREATE_TIME" property="createTime" />
		<result column="CREATOR" property="creator" />
		<result column="UPDATE_TIME" property="updateTime" />
		<result column="UPDATOR" property="updator" />
	</resultMap>

	<!-- 使用extends继承 -->
	<resultMap type="com.cal.base.system.entity.dto.UserDTO" id="UserDtoResultMap" extends="BaseResultMap">
		<!-- 配置映射的关联 -->
		<!-- association：用于映射关联查询单个对象的信息 property：要将关联查询用户组织信息映射到UserDTO中哪个属性 javaType：映射到UserDTO的哪个属性类型 -->
		<association property="userOrganization"
			javaType="com.cal.base.system.entity.po.UserOrganization">
			<result column="ORGANIZATION_ID" property="organizationId" />
		</association>
		<!-- 角色信息-要去重(看映射回来的数据不想等)，关键是通过主键识别(id)，配置了能够保证去重
		一个用户关联查询出多个角色，要使用collection进行映射
		collection：对关联查询到多条记录映射到集合对象中
		property：将关联查询到多条记录映射到com.cal.base.system.entity.dto.UserDTO哪个属性
		ofType：指定映射到list集合属性中pojo的类型
		 -->
		 <collection property="role" ofType="com.cal.base.system.entity.po.Role">
		 <!-- id：角色唯 一标识
		 	property:要将角色唯 一标识映射到com.cal.base.system.entity.po.Role的哪个属性
		 	  -->
		 	<!-- <id column="ROLE_ID" property="roleId"/> -->
		 	<result column="ROLE_NAME" property="name"/>
		 </collection>
	</resultMap>

	<!-- 针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。 -->
	<select id="listAll" resultMap="UserDtoResultMap">
		SELECT 
			MAIN.USER_ID, 
			MAIN.ACCOUNT, 
			MAIN.NAME, 
			MAIN.PASSWORD, 
			MAIN.PHONE,
			MAIN.SEX, 
			MAIN.SYSCODE,
			MAIN.ORG_ID,
			MAIN.IS_ENABLED, 
			MAIN.REMARK,
			MAIN.CREATE_TIME, 
			MAIN.CREATOR,
			MAIN.UPDATE_TIME, 
			MAIN.UPDATOR,
			UO.ORGANIZATION_ID,
			ROLE.ROLE_ID,
			ROLE.NAME ROLE_NAME
		FROM SYSTEM_USER MAIN 
		LEFT JOIN SYSTEM_USER_ORGANIZATION UO ON MAIN.USER_ID = UO.USER_ID
		LEFT JOIN SYSTEM_USER_ROLE UR ON MAIN.USER_ID = UR.USER_ID
		LEFT JOIN SYSTEM_ROLE ROLE ON UR.ROLE_ID = ROLE.ROLE_ID
	</select>

	<!-- 定义sql片段 id：sql片段的唯 一标识 经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高 在sql片段中不要包括 
		where -->
	<sql id="Base_Column_List">
		USER_ID, ACCOUNT, NAME, PASSWORD, PHONE,
		SEX, SYSCODE,
		ORG_ID, IS_ENABLED, REMARK,
		CREATE_TIME, CREATOR,
		UPDATE_TIME, UPDATOR
	</sql>

	<!-- 使用resultMap进行输出映射 resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件中，前边需要加namespace -->
	<!-- 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 -->
	<select id="selectByPrimaryKey" resultMap="BaseResultMap" >
		select
		<include refid="Base_Column_List" />
		from system_user
		where USER_ID = #{userId}
	</select>

	<!-- 查询条件sql片段 -->
	<sql id="Query_Condition">
		<if test="account != null and account != ''">
			AND ACCOUNT = #{account}
		</if>
		<if test="name != null and name != ''">
			AND NAME = #{name}
		</if>
		<if test="phone != null and phone != ''">
			AND PHONE = #{phone}
		</if>
		<if test="sex != null and sex != ''">
			AND SEX = #{sex}
		</if>
		<if test="isEnabled != null and isEnabled != ''">
			AND IS_ENABLED = #{isEnabled}
		</if>
		<if test="ids != null and ids != ''">
			<!-- 使用 foreach遍历传入ids collection：指定输入对象中集合属性 item：每个遍历生成对象中 open：开始遍历时拼接的串 
				close：结束遍历时拼接的串 separator：遍历的两个对象中需要拼接的串 -->
			<!-- 实现 and USER_ID IN(1,10,16) 拼接 -->
			<foreach collection="ids" item="id" index="index" open="AND USER_ID IN ("
				close=")" separator=",">
				<!-- 每个遍历需要拼接的串 -->
				#{id}
			</foreach>
			<!-- 使用 foreach遍历传入ids collection：指定输入 对象中集合属性 item：每个遍历生成对象中 open：开始遍历时拼接的串 
				close：结束遍历时拼接的串 separator：遍历的两个对象中需要拼接的串 -->
		</if>
	</sql>

	<!-- 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。 
		只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。 -->
	<!-- 查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。 -->
	<!-- 不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。 
		在mapper.java指定的方法返回值类型不一样 -->
	<!-- 生成的动态代理对象中是根据mapper方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList （返回集合对象调用 
		）. -->
	<select id="listAll2" resultMap="BaseResultMap">
		select
		<!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace -->
		<include refid="Base_Column_List" />
		from system_user
		<!-- where可以自动去掉条件中的第一个and -->
		<where>
			<include refid="Query_Condition" />
			<!-- 在这里还要引用其它的sql片段 -->
		</where>
		order by create_time desc
	</select>

	<delete id="deleteByPrimaryKey">
		delete from system_user
		where
		USER_ID = #{userId}
	</delete>
	
	<insert id="batchInsert" keyProperty="userId" useGeneratedKeys="true">
		insert into system_user(ACCOUNT, NAME)
		values
		<foreach collection="list" item="user" separator=",">
			(#{user.account},#{user.name})
		</foreach>
	</insert>

	<!-- 添加用户 parameterType：指定输入 参数类型是pojo（包括用户信息） #{}中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值 -->
	<insert id="insertSelective" parameterType="User" useGeneratedKeys="true" keyProperty="userId">
		insert into system_user
		<!-- 将插入数据的主键返回，返回到user对象中 SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键 
			keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序 
			resultType：指定SELECT LAST_INSERT_ID()的结果类型 -->
		<!-- <selectKey keyProperty="userId" order="AFTER" resultType="java.lang.Long">
			SELECT LAST_INSERT_ID()
		</selectKey> -->
		<!-- 使用mysql的uuid（）生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 -->
		<!-- <selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String"> 
			SELECT uuid() </selectKey> -->
		<trim prefix="(" suffix=")" suffixOverrides=",">
			<if test="account != null">
				ACCOUNT,
			</if>
			<if test="name != null">
				NAME,
			</if>
			<if test="password != null">
				PASSWORD,
			</if>
			<if test="phone != null">
				PHONE,
			</if>
			<if test="sex != null">
				SEX,
			</if>
			<if test="syscode != null">
				SYSCODE,
			</if>
			<if test="orgId != null">
				ORG_ID,
			</if>
			<if test="isEnabled != null">
				IS_ENABLED,
			</if>
			<if test="remark != null">
				REMARK,
			</if>
			<if test="createTime != null">
				CREATE_TIME,
			</if>
			<if test="creator != null">
				CREATOR,
			</if>
			<if test="updateTime != null">
				UPDATE_TIME,
			</if>
			<if test="updator != null">
				UPDATOR,
			</if>
		</trim>
		<trim prefix="values (" suffix=")" suffixOverrides=",">
			<if test="account != null">
				#{account},
			</if>
			<if test="name != null">
				#{name},
			</if>
			<if test="password != null">
				#{password},
			</if>
			<if test="phone != null">
				#{phone},
			</if>
			<if test="sex != null">
				#{sex},
			</if>
			<if test="syscode != null">
				#{syscode},
			</if>
			<if test="orgId != null">
				#{orgId},
			</if>
			<if test="isEnabled != null">
				#{isEnabled},
			</if>
			<if test="remark != null">
				#{remark},
			</if>
			<if test="createTime != null">
				#{createTime},
			</if>
			<if test="creator != null">
				#{creator},
			</if>
			<if test="updateTime != null">
				#{updateTime},
			</if>
			<if test="updator != null">
				#{updator},
			</if>
		</trim>
	</insert>

	<update id="updateByPrimaryKeySelective">
		update system_user
		<set>
			<if test="account != null">
				ACCOUNT = #{account},
			</if>
			<if test="name != null">
				NAME = #{name},
			</if>
			<if test="password != null">
				PASSWORD = #{password},
			</if>
			<if test="phone != null">
				PHONE = #{phone},
			</if>
			<if test="sex != null">
				SEX = #{sex},
			</if>
			<if test="isEnabled != null">
				IS_ENABLED = #{isEnabled},
			</if>
			<if test="remark != null">
				REMARK = #{remark},
			</if>
			<if test="updateTime != null">
				UPDATE_TIME = #{updateTime},
			</if>
			<if test="updator != null">
				UPDATOR = #{updator},
			</if>
		</set>
		where USER_ID = #{userId}
	</update>
</mapper>